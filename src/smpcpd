#! /usr/bin/env bash

#
# .▄▄ · • ▌ ▄ ·.  ▄▄▄· ▄▄·  ▄▄▄· super
# ▐█ ▀. ·██ ▐███▪▐█ ▄█▐█ ▌▪▐█ ▄█ music
# ▄▀▀▀█▄▐█ ▌▐▌▐█· ██▀·██ ▄▄ ██▀· player
# ▐█▄▪▐███ ██▌▐█▌▐█▪·•▐███▌▐█▪·• client
#  ▀▀▀▀ ▀▀  █▪▀▀▀.▀   ·▀▀▀ .▀    plus+
#
# This file is part of smpcp.
# Copyright (C) 2021, Stéphane MEYER.
#
# Smpcp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>
#
# SMPCPD
# C : 2021/04/10
# M : 2021/04/16
# D : Music non stop daemon.

declare SMPCP_LIB="/usr/lib/smpcp"
declare SMPCP_PID="$HOME/.config/smpcp/pid"

# shellcheck source=/usr/lib/smpcp/client.sh
source "$SMPCP_LIB"/client.sh
# shellcheck source=/usr/lib/smpcp/core.sh
source "$SMPCP_LIB"/core.sh
# shellcheck source=/usr/lib/smpcp/player.sh
source "$SMPCP_LIB"/player.sh
# shellcheck source=/usr/lib/smpcp/playlist.sh
source "$SMPCP_LIB"/playlist.sh
# shellcheck source=/usr/lib/smpcp/tracker.sh
source "$SMPCP_LIB"/tracker.sh
# shellcheck source=/usr/lib/smpcp/statistics.sh
source "$SMPCP_LIB"/statistics.sh
# shellcheck source=/usr/lib/smpcp/volume.sh
source "$SMPCP_LIB"/volume.sh

declare URI

# check if an instance is already running.
[[ -s "$SMPCP_PID" ]] && {
  pid="$(<"$SMPCP_PID")"
  check_pid "$pid" && {
    __msg E "($pid) an instance is already running."
    exit 1
  }
}

# save current pid.
echo "$$" > "$SMPCP_PID"

notify_song() {
  # display a song change notification.
  if [[ $(read_config dim) == "on" ]]; then
    notify-send -i "$(get_albumart)" -u low "$(status)"
  else
    notify-send -i "$(get_albumart)" "$(status)"
  fi
}

play_event() {
  URI="$(get_current)"
  volume auto
  notify_song
  media_update
  # handle playlist generator here vvv
}

pause_event() {
  media_update
  [[ $(read_config single) == "on" ]] && {
    single 0 &> /dev/null
    write_config single off
  }
}

stop_event() {
  media_update
  [[ $(read_config single) == "on" ]] && {
    single 0 &> /dev/null
    write_config single off
  }
  write_config dim off
}

change_event() {
  URI="$(get_current)"
  notify_song
  media_update
  # handle playlist generator here vvv
}

end_event() {
  update_stats "$URI"
}

#
trap clear_media INT QUIT TERM

while read -r; do
  # react to player events
  # play
  # pause
  # stop
  # change
  # end

  echo "$REPLY"

  case $REPLY in
    play  ) play_event ;;
    pause ) pause_event ;;
    stop  ) stop_event ;;
    change) change_event ;;
    end   ) end_event
  esac

done < <(tracker)
